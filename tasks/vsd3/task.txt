В этом заднии мы сделаем наш виртуальное устройство хранения данных
(VSD) более похожим на реальное.

Теперь модуль vsd не просто создает VSD устройство на шине platform_bus
и выделяет для него буфер в ядерной памяти. Созданное на шине
platform_bus VSD устройство теперь представляет из себя отдельного
от vsd_driver агента, который принимает команды от vsd_driver по
интерфейсу, расположенному в общей физической памяти. По нему же
VSD возвращает результат выполнения команды и уведомляет vsd_driver
о завершении обработки команды.

Рассмотрим пример обработки команды на чтение VSD из userspace.

1. Userspace приложение аллоцирует буфер, в который должны прочитаться
   данные из VSD.

2. Userspace приложение выполняет системный вызов sys_read в файловый
   дескриптор, полученный при открытии ноды vsd_driver /dev/vsd

3. vsd_driver в обработчике системного вызова vsd_dev_read ждет пока
   будет захвачен мьютекс dev_ops_serialization_mutex, который ставит
   все userspace приложения в общую очередь и выполняет их системные
   вызовы по одному (выполнение запросов параллельно намного сложнее).

4. vsd_driver аллоцирует участок непрерывной физической памяти (почему?),
   достаточный для записи туда данных, которые хочет прочитать
   userspace приложение.

5. vsd_driver заполняет виртуальные регистры VSD - пишет туда адрес
   буфера физической памяти, его размер, смещение внутри VSD и номер
   команды "чтение" VSD_CMD_READ.

6. vsd_driver ставит поток в очередь dma_op_compete_wq
   для ожидание завершения обработки команды VSD_CMD_READ устройством VSD.

7. У VSD есть свой "процессор" - поток, который раз в секунду проверяет
   состояние виртуальных регистров VSD и выполняет запрошенную команду,
   если таковая поступила.

8. VSD выполняет команду, кладет результат выполнения в виртуальные
   регистры и будит ожидающий поток, вставший в очереди ожидания
   dma_op_complete_tsk.

9. Пробуждение осуществляется путем запуска "программного прерывания",
   а точнее tasklet, который при своем исполнении разбудит ожидающий
   в очереди dma_op_complete_tsk поток.

10.Ожидающий поток просыпается, забирает результат выполнения из
   виртуальных регистров VSD, осовобождает мьютекс
   dev_ops_serialization_mutex и завершает системный вызов.

=========================================
Задание.

1. В обработчике тасклета vsd_dev_dma_op_complete_tsk_func
   разбудите поток, ожидающий завершения обработки команды VSD.

2. Реализуйте команду VSD_CMD_SET_SIZE в модулях vsd_device
   и vsd_driver.
   Тест vsd_userspace/vsd_test.c поможет вам проверить правильность
   выполнения задания.

3. Сделайте очередь из userspace потоков, ожидающих завершения системных
   вызовов в vsd_driver при помощи функций mutex_lock, mutex_unlock.
   vsd_dev->dev_ops_serialization_mutex, служащий для этой цели уже создан
   и проинициализирован.

4. Добавьте одну проверку в функции vsd_dev_write и vsd_dev_read,
   которая защитит от аллокации слишком больших буферов DMA (kmalloc).
   Команды исполняются VSD устройством, но вы можете заранее проверить
   на совсем невероятные размеры IO на VSD.

5. Ответьте на вопрос внутри функции vsd_dev_write прямо в комментариях.
